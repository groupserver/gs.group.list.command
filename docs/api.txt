:mod:`gs.group.list.command` API Reference
==========================================

The API for email-commands is in three parts: `processing
commands`_, `registering command processors`_, and `the result
enumeration`_.

Processing commands
-------------------

The :func:`gs.group.list.command.process_command` function is
used to process the commands in an email message.

.. autofunction:: gs.group.list.command.process_command

Example
~~~~~~~

::

  r = process_command(self.group, email)
  if r == gs.group.list.command.CommandResult.commandStop:
    return

Registering command processors
------------------------------

The commands are named *utilities*, that implement the
:class"`gs.group.list.command.interfaces.IEmailCommand`
interface. The *name* is the command-name in **lower case.** So
the command to unsubscribe someone from a group will have the
utility name ``unsubscribe``. The utility must 

* Take the group in the :meth:`__init__` method,
* Provide a :meth:`process` method that takes the email as an
  argument.

Example
~~~~~~~

I prefer to declare utilities using ZCML. This will declare a
command called ``example``, which is implemented by the
:class:`ExampleCommand` class in the :mod:`example` module in the
local directory:

.. code-block:: xml

  <utility
    name="example"
    provides="gs.group.list.command.interfaces.IEmailCommand" 
    component=".example.ExampleCommand" />

The :mod:`example` module would contain the
:class:`ExampleCommand` class.

.. code-block:: python

  from gs.group.list.command import CommandResult.commandStop:
  class ExampleCommand(object):
      def __init__(self, group):
          self.group = group

      def process(email):
          # TODO: Stuff
          return CommandResult.commandStop

The Result Enumeration
----------------------

The result enumeration is returned by the
:func:`gs.group.list.command.process_command` function, and the
command that are registered.

.. autoclass:: gs.group.list.command.CommandResult
   :members:
